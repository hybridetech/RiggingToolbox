/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;
require FabricStatistics;

object SkinningDeformer : BaseDeformer {

  UInt32 dataVersion;
  Mat44 invReferencePose[];
  Mat44 skinningMatrices[];
  Mat44 bindShapeTransforms[];
};


function String[] SkinningDeformer.getRequiredAttributes(){
  String result[];
  result.push('positions');
  result.push('normals');
  result.push('skinningData');
  return result;
}

function String[] SkinningDeformer.getModifiedAttributes(){
  String result[];
  result.push('positions');
  result.push('normals');
  return result;
}

function SkinningDeformer.setReferencePose!(Mat44 referencePose[]){
  this.invReferencePose.resize(referencePose.size);
  for (Integer i = 0; i < referencePose.size; i++)
    this.invReferencePose[i] = referencePose[i].inverse();
  this.skinningMatrices.resize(referencePose.size);
}

function SkinningDeformer.setReferencePoseFromSkeleton!(Skeleton skeleton){
  Size deformerIndices[] = skeleton.getDeformerIndices();
  Mat44 referencePose[];
  referencePose.resize(deformerIndices.size);
  for (Integer i = 0; i < deformerIndices.size; i++)
    referencePose[i] = skeleton.getBone(deformerIndices[i]).referencePose.toMat44();
  this.setReferencePose(referencePose);
}

function SkinningDeformer.setPose!(Mat44 pose[]){
  if(pose.size != this.invReferencePose.size){
    setError('Pose count does not match the reference pose count referencePose:' + this.invReferencePose.size + " != " + pose.size);
    return;
  }
  for (Integer i = 0; i < pose.size; i++) {
    this.skinningMatrices[i] = pose[i] * this.invReferencePose[i];
  }
  String data;
  this.notify('changed', data);
}

/// The per-point operator that computes the linear blend skinning. 
/// \internal
operator skinningDeformer_skinPositions<<<index>>>(
  io Vec3 positions[],
  SkinningAttribute skinningAttr,
  Mat44 skinningPosAndNormMatrices[]
){
  Vec3 srcPos = positions[index];

  LocalL16UInt32Array indices;
  LocalL16ScalarArray weights;
  skinningAttr.getPairs(index, indices, weights);

  Vec3 position(0,0,0);
  for( UInt32 i = 0; i < indices.size(); ++i ) {
    Scalar boneWeight = weights.get(i);
    if( boneWeight == 0.0 )
      break;
    UInt32 boneId = indices.get(i);
    position += (skinningPosAndNormMatrices[boneId*2] * srcPos) * boneWeight;
  }

  positions[index] = position;
}

/// The per-point operator that computes the linear blend skinning. 
/// \internal
operator skinningDeformer_skinPositionsAndNormals<<<index>>>(
  io Vec3 positions[],
  io Vec3 normals[],
  SkinningAttribute skinningAttr,
  Mat44 skinningPosAndNormMatrices[]
){
  Vec3 srcPos = positions[index];
  Vec3 srcNorm = normals[index];
  Vec3 position(0,0,0);
  Vec3 normal(0,0,0);

  LocalL16UInt32Array indices;
  LocalL16ScalarArray weights;
  skinningAttr.getPairs(index, indices, weights);
  
  for( UInt32 i = 0; i < indices.size(); ++i ) {
    Scalar boneWeight = weights.get(i);
    if( boneWeight == 0.0 )
      break;
    UInt32 boneId = indices.get(i);
    position += (skinningPosAndNormMatrices[boneId*2] * srcPos) * boneWeight;
    normal += (skinningPosAndNormMatrices[boneId*2+1] * srcNorm) * boneWeight;
  }
  Scalar length = normal.length();//Don't call setUnit to avoid runtime error reports..
  if( length > 0.0001 )
    normal *= 1.0 / length;

  positions[index] = position;
  normals[index] = normal;
}

/// Computes the deformation of the character using linear blend skinning. 
/// \internal
operator deformGeometries<<<index>>>(
  io GeometrySet geomSet,
  Mat44 skinningPosAndNormMatrices[]
){
  Ref<GeometryAttributes> attributes = geomSet.get(index).getAttributes();

  if( !attributes.has("skinningData") ){
    setError("ERROR: Geometry does not have skinningData");
    return;
  }
  
  Vec3Attribute positionsAttribute = attributes.positionsAttribute;
  Vec3Attribute normalsAttribute = attributes.normalsAttribute;
  SkinningAttribute skinningAttr = attributes.getAttribute("skinningData");

  if(normalsAttribute == null){
    skinningDeformer_skinPositions<<<attributes.size()>>>(
      positionsAttribute.values,
      skinningAttr,
      skinningPosAndNormMatrices
    );
    positionsAttribute.incrementVersion();
  }
  else{
    skinningDeformer_skinPositionsAndNormals<<<attributes.size()>>>(
      positionsAttribute.values,
      normalsAttribute.values,
      skinningAttr,
      skinningPosAndNormMatrices
    );
    positionsAttribute.incrementVersion();
    normalsAttribute.incrementVersion();
  }
}

function SkinningDeformer.evaluate(EvalContext context, io GeometrySet geomSet){

  AutoProfilingEvent p(FUNC);
  if(this.dataVersion != geomSet.getVersion()){
    // create an io this pointer so we can cache the values. 
    Ref<SkinningDeformer> io_this = this;
    io_this.bindShapeTransforms.resize(geomSet.size);
    for(Integer i=0; i<geomSet.size; i++){
      Geometry geometry = geomSet.get(i);
      Ref<GeometryAttributes> attributes = geometry.getAttributes();
      if( !attributes.has("skinningData") ){
        setError("ERROR: Geometry does not have skinningData:" + getGeomDebugName(geometry));
        return;
      }
      ThreadsafeMetaDataContainer metaData = getGeomMetaData(geometry);
      GenericMat44Value bindShapeTransform = metaData.get('bindShapeTransform');
      if(bindShapeTransform){
        io_this.bindShapeTransforms[i] = bindShapeTransform.value;
      }
    }
    if(geomSet.hasMetaData('skeleton')){
      Skeleton skeleton = geomSet.getMetaData('skeleton');
      if(skeleton)
        io_this.setReferencePoseFromSkeleton(skeleton);
    }
    io_this.dataVersion = geomSet.getVersion();
  }

  Mat44 skinningPosAndNormMatrices[];
  skinningPosAndNormMatrices.resize( this.skinningMatrices.size()*2 );
  for( UInt32 i = 0; i < this.skinningMatrices.size(); ++i ) {
    skinningPosAndNormMatrices[i*2] = this.skinningMatrices[i];// * this.bindShapeTransforms[i];
    skinningPosAndNormMatrices[i*2 + 1] = skinningPosAndNormMatrices[i*2];
    skinningPosAndNormMatrices[i*2 + 1].zeroTranslation();
  }

  deformGeometries<<<geomSet.size()>>>(geomSet, skinningPosAndNormMatrices);
}

